#!/usr/bin/env ruby
# frozen_string_literal: true

require 'rubygems'
require 'bundler/setup'
require 'openssl'
require 'open-uri'
require 'net/https'
require 'tempfile'

COMPILER_MEMFS = '/__enclose_io_memfs__'

def determine_cert_path
  return "#{File.expand_path(File.dirname(__FILE__))}/cacert.pem.mozilla" if Gem.win_platform?

  path = "#{COMPILER_MEMFS}/local/vendor/cacert.pem.mozilla"
  return path if File.file?(path)

  File.join('vendor', 'cacert.pem.mozilla')
end

def cert_file_path
  cert_tempfile = Tempfile.new
  cert_tempfile.tap { |n| n.puts(File.read(determine_cert_path)) }.close
  cert_file_path = cert_tempfile.path
end

unless Gem.win_platform? # because on windows we use ocra
  # https://github.com/pmq20/ruby-packer/blob/master/lib/compiler/constants.rb#L10
  COMPILER_MEMFS_LIB_CACHE = Pathname.new(Dir.mktmpdir)
  at_exit {
    FileUtils.remove_dir(COMPILER_MEMFS_LIB_CACHE.to_path, true)
  }

  def extract_memfs(file, wild=false, extract_path=COMPILER_MEMFS_LIB_CACHE)
    return file unless file.start_with? COMPILER_MEMFS

    memfs_extracted_file = extract_path + File.basename(file)
    unless memfs_extracted_file.exist?
      if wild
        files = Dir.glob("#{File.dirname(file)}/*#{File.extname(file)}")
        FileUtils.cp_r files, extract_path
      else
        FileUtils.cp file, memfs_extracted_file
      end
    end

    memfs_extracted_file.to_path
  end

  # HACK: extract temp libraries to use with ffi
  # Wrapper for FFI.map_library_name method
  require 'ffi'
  require 'pathname'

  module FFI
    # https://stackoverflow.com/questions/29907157/how-to-alias-a-class-method-in-rails-model/29907207
    self.singleton_class.send(:alias_method, :map_library_name_orig, :map_library_name)

    # http://tech.tulentsev.com/2012/02/ruby-how-to-override-class-method-with-a-module/
    def self.map_library_name(lib)
      map_library_name_orig(extract_memfs(lib))
    end
  end
  # END of HACK

  # HACK unpack jing jar
  require 'jing'
  require 'optout'

  class Jing
    def self.option_builder
      @@option_builder
    end

    def validate(xml)
      @options[:xmlfile] = extract_memfs(xml)
      @options[:schema] = extract_memfs(@options[:schema], true)

      out = execute(@options)
      return [] if $?.success? and out.empty?
      errors = parse_output(out)
      raise ExecutionError, out if errors.none? # There must have been a problem that was not schema related
      errors
    end
  end

  class Optout
    def []=(name, value)
      @options[name] = value
    end
  end

  Jing.option_builder[:jar] = Optout::Option.create(:jar, '-jar',
    :index => 1,
    :validator => Optout::File.exists,
    :default => extract_memfs(Jing::DEFAULT_JAR)
  )
  # END of HACK

  # HACK unpack mn2pdf and mn2sts jar
  require 'mn2pdf'
  module Mn2pdf
    MN2PDF_JAR_PATH = extract_memfs(File.join(Gem.loaded_specs['mn2pdf'].full_gem_path, 'bin', 'mn2pdf.jar'))

    self.singleton_class.send(:alias_method, :convert_orig, :convert)

    def self.convert(url_path, output_path, xsl_stylesheet)
      convert_orig(extract_memfs(url_path), output_path, extract_memfs(xsl_stylesheet))
    end
  end

  require 'mn2sts'
  module Mn2sts
    MN2STS_JAR_PATH = extract_memfs(File.join(Gem.loaded_specs['mn2sts'].full_gem_path, 'bin', 'mn2sts.jar'))

    self.singleton_class.send(:alias_method, :convert_orig, :convert)

    def self.convert(xml_path_in, xml_path_out)
      convert_orig(extract_memfs(xml_path_in), xml_path_out)
    end
  end
  # END of HACK

  # HACK unpack saasc styles
  require 'sassc'
  base_style = COMPILER_MEMFS_LIB_CACHE + 'base_style'
  base_style.mkpath()
  extract_memfs(File.join(Gem.loaded_specs['isodoc'].full_gem_path, 'lib', 'isodoc', 'base_style', '*'), true, base_style)
  SassC.load_paths << COMPILER_MEMFS_LIB_CACHE 
  # END of HACK
end

cert_file_path = nil
DEBUG = ENV['DEBUG']

# Check ssl availability, if not use vendor ssl certificate
begin
  Net::HTTP.get(URI('https://www.iso.org/'))
rescue OpenSSL::SSL::SSLError
  puts('Cannot use SSL requests, installing custom certificate') if DEBUG
  Net::HTTP.class_eval do
    alias _use_ssl= use_ssl=

    def use_ssl= boolean
      self.ca_file = cert_file_path
      self.verify_mode = OpenSSL::SSL::VERIFY_PEER
      self._use_ssl = boolean
    end
  end
end

# explicitly load all dependent gems
# ruby packer cannot use gem load path correctly.
require 'isodoc'
require 'metanorma-iso'
require 'metanorma-standoc'
require 'metanorma-generic'
require 'metanorma-csa'
require 'metanorma-cc'
require 'metanorma-gb'
require 'metanorma-iec'
require 'metanorma-ietf'
require 'metanorma-itu'
require 'metanorma-m3aawg'
require 'metanorma-nist'
require 'metanorma-ogc'
require 'metanorma-ribose' unless Gem.win_platform? # workaround for ocra
require 'metanorma-mpfa' unless Gem.win_platform? # workaround for ocra
require 'metanorma-un'
require 'metanorma'
require 'nokogiri'
require 'git'
require 'metanorma/cli'
require 'sassc'
require 'thor'

# start up the CLI
Metanorma::Cli.start(ARGV)