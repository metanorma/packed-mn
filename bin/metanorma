#!/usr/bin/env ruby
# frozen_string_literal: true

require 'pathname'
require 'tempfile'
require 'fileutils'

COMPILER_MEMFS = '/__tebako_memfs__'
COMPILER_MEMFS_LIB_CACHE = Pathname.new(Dir.mktmpdir("packed-mn-"))
at_exit {
  FileUtils.remove_dir(COMPILER_MEMFS_LIB_CACHE.to_path, true)
}

ENV['BUNDLE_PATH'] = COMPILER_MEMFS_LIB_CACHE.to_s
FileUtils.mkdir_p(COMPILER_MEMFS_LIB_CACHE / 'ruby/2.7.0')
require 'bundler/inline'

gemfile do
  source 'https://rubygems.org'

  if Gem.win_platform?
    gem "fontist"
    gem "net-ssh"
    gem "zlib"
  end

  gem "ffi"
  gem "rake"
  gem "sassc"
  gem "seven_zip_ruby"

  gem "metanorma-cli", "= 1.5.9"
end

require 'openssl'
require 'open-uri'
require 'net/https'

# Limit Relaton to concurrent fetches of 1
ENV["RELATON_FETCH_PARALLEL"] = "1"

def determine_cert_path
  return "#{File.expand_path(File.dirname(__FILE__))}/cacert.pem.mozilla" if Gem.win_platform?

  path = "#{COMPILER_MEMFS}/local/vendor/cacert.pem.mozilla"
  return path if File.file?(path)

  File.join('vendor', 'cacert.pem.mozilla')
end

def cert_file_path
  cert_tempfile = Tempfile.new
  cert_tempfile.tap { |n| n.puts(File.read(determine_cert_path)) }.close
  cert_file_path = cert_tempfile.path
end

def full_gem_path(gem)
  Gem::Specification.find_by_name(gem).full_gem_path
end

unless Gem.win_platform? # because on windows we use ocra
  class String
    def is_quoted
      self.start_with?('"') && self.end_with?('"')
    end

    def unquote
      self.chomp('"').reverse.chomp('"').reverse
    end

    def quote
      "\"#{self}\""
    end
  end

  def extract_memfs(file, wild=false, extract_path=COMPILER_MEMFS_LIB_CACHE)
    is_quoted = file.is_quoted
    file = file.unquote if is_quoted

    return file unless File.exist?(file) && file.start_with?(COMPILER_MEMFS)

    memfs_extracted_file = extract_path + File.basename(file)
    unless memfs_extracted_file.exist?
      files = if wild
        Dir.glob("#{File.dirname(file)}/*#{File.extname(file)}")
      else
        [file]
      end
      FileUtils.cp_r files, extract_path
    end

    is_quoted ? memfs_extracted_file.to_path.quote : memfs_extracted_file.to_path
  end

  # HACK: extract temp libraries to use with ffi
  # Wrapper for FFI.map_library_name method
  require 'ffi'
  require 'pathname'

  module FFI
    # https://stackoverflow.com/questions/29907157/how-to-alias-a-class-method-in-rails-model/29907207
    self.singleton_class.send(:alias_method, :map_library_name_orig, :map_library_name)

    # http://tech.tulentsev.com/2012/02/ruby-how-to-override-class-method-with-a-module/
    def self.map_library_name(lib)
      map_library_name_orig(extract_memfs(lib))
    end
  end
  # END of HACK

  # HACK unpack jing jar
  require 'jing'
  require 'optout'

  class Jing
    def self.option_builder
      @@option_builder
    end

    def validate(xml)
      @options[:xmlfile] = extract_memfs(xml)
      @options[:schema] = extract_memfs(@options[:schema], true)

      out = execute(@options)
      return [] if $?.success? and out.empty?
      errors = parse_output(out)
      raise ExecutionError, out if errors.none? # There must have been a problem that was not schema related
      errors
    end
  end

  class Optout
    def []=(name, value)
      @options[name] = value
    end
  end

  Jing.option_builder[:jar] = Optout::Option.create(:jar, '-jar',
    :index => 1,
    :validator => Optout::File.exists,
    :default => extract_memfs(Jing::DEFAULT_JAR)
  )
  # END of HACK

  # HACK unpack mn2pdf.jar
  require 'mn2pdf'
  module Mn2pdf
    remove_const('MN2PDF_JAR_PATH')
    MN2PDF_JAR_PATH = extract_memfs(File.join(full_gem_path('mn2pdf'), 'bin', 'mn2pdf.jar'))

    self.singleton_class.send(:alias_method, :convert_orig, :convert)
    self.singleton_class.send(:remove_method, :convert)

    def self.convert(url_path, output_path, xsl_stylesheet, options)
      convert_orig(extract_memfs(url_path), output_path, extract_memfs(xsl_stylesheet), options)
    end
  end
  # END of HACK

  # HACK unpack mnconvert.jar
  require 'mnconvert'
  module MnConvert
    remove_const('MNCONVERT_JAR_PATH')
    MNCONVERT_JAR_PATH = extract_memfs(File.join(full_gem_path('mnconvert'), 'bin', 'mnconvert.jar'))

    self.singleton_class.send(:alias_method, :convert_orig, :convert)
    self.singleton_class.send(:remove_method, :convert)

    def self.convert(input_file, output_file, input_format, opts = {})
      opts[:xsl_file] = extract_memfs(opts[:xsl_file]) if opts[:xsl_file]
      convert_orig(extract_memfs(input_file), output_file, input_format, opts)
    end
  end
  # END of HACK

  # HACK fix path for 7zip load
  sevenz_lib = RUBY_PLATFORM.downcase.match(/mswin|mingw/) ? "7z*.dll" : "7z.so"
  sevenz_path = File.join(full_gem_path('seven_zip_ruby'), 'lib', 'seven_zip_ruby', sevenz_lib)
  FileUtils.mkdir_p(COMPILER_MEMFS_LIB_CACHE / 'seven_zip_ruby')
  FileUtils.cp(sevenz_path, COMPILER_MEMFS_LIB_CACHE / 'seven_zip_ruby')
  $LOAD_PATH.unshift(COMPILER_MEMFS_LIB_CACHE)
  # END of HACK

  # HACK unpack style files for sassc
  require 'sassc'
  
  module SassC
    class Engine
      @@loaded_pathes = []
      @@loaded_pathes_semaphore = Mutex::new
      def load_paths()
        paths = (@options[:load_paths] || []) + SassC.load_paths
          np = []
          paths.each { |p|
            if p.start_with?(COMPILER_MEMFS)
              m = p.sub(COMPILER_MEMFS, COMPILER_MEMFS_LIB_CACHE.to_s)
              @@loaded_pathes_semaphore.synchronize {
                unless @@loaded_pathes.include?(m)
                  FileUtils.mkdir_p(m)
                  FileUtils.cp_r(File.join(p, "."), m) if File.exists?(p)
                  @@loaded_pathes << m
                end
              }
              np << m
            else
              np << p
            end          
          }
        np.join(File::PATH_SEPARATOR) unless np.empty?
      end
    end
  end
  # END of HACK/sassc

end

if Gem.win_platform?
  # HACK unpack jing chcp 65001
  require 'jing'
  require 'optout'

  class Jing
    def execute(options)
      cmd = @@option_builder.shell(options)
      `#{cmd} 2>&1`.encode("UTF-8", :invalid=>:replace, :replace=>"_?_")
    rescue SystemCallError => e
      raise ExecutionError, "jing execution failed: #{e}"
    rescue Optout::OptionError => e
      raise OptionError, e.message
    end
  end
  # END of HACK

  require 'ffi-libarchive-binary' # to preload libarchive-13.dll
end

Net::HTTP.class_eval do
  alias _use_ssl= use_ssl=

  def use_ssl= boolean
    self.ca_file = cert_file_path
    self.verify_mode = OpenSSL::SSL::VERIFY_PEER
    self._use_ssl = boolean
  end
end

# explicitly load all dependent gems
# ruby packer cannot use gem load path correctly.
require 'isodoc'
require 'metanorma-iso'
require 'metanorma-standoc'
require 'metanorma-generic'
require 'metanorma-csa'
require 'metanorma-cc'
require 'metanorma-iec'
require 'metanorma-ietf'
require 'metanorma-itu'
require 'metanorma-m3aawg'
require 'metanorma-ogc'
require 'metanorma-un'
require 'metanorma'
require 'nokogiri'
require 'git'
require 'metanorma/cli'
require 'thor'

# start up the CLI
Metanorma::Cli.start(ARGV)
